classdef PixelClassifier
  
    properties(GetAccess = public, SetAccess = private);
        Filepath,
        Model, 
        ReturnType,
        Key = {'LUMEN', 'STROMA', 'CYTOPLASM', 'NUCLEI', 'INFLAMMATION', 'FIXATIVE', 'INTRALUMINAL'}
    end
    
    methods
        
        %%%%%%%%%%%%%%%%%%%%%%
        % Constructor method %
        %%%%%%%%%%%%%%%%%%%%%%
        function this = PixelClassifier()
            
            filepath = 'models/NB-PixelClassifier.LAB.ind.mat';
            
            this.Filepath = filepath;
            
            loaded = load(filepath);
            this.Model = loaded.NB;
            
            this.ReturnType = 'greyscale';
            
            clear('loaded', 'filepath');    % Removes the loaded var 
        end
        
        
        %%%%%%%%%%%%%%%%%%   % Returns classified image scaled to uint8 values
        % Classify Image %
        %%%%%%%%%%%%%%%%%%
        function cimg = GetClassifiedImage(this, img)
            
            if (~size(img, 3) == 3)                 % If parameter image does not have 3 channels ..
                if (size(img, 3) == 4)              % Check if it's just an alpha channel ..
                   img = img(:,:,1:3);              % Remove alpha channel 
                else
                    error('PixelClassifier:Classify', 'Parameter image must be a colour image.');
                end
            end
           
            img = applycform(img, makecform('srgb2lab'));                  % Convert image to LAB colourspace. (Presuming the model used it originally)
            
            [X Y Z] = size(img);                    % Get image dimensions
            
            img = reshape(img, X*Y, Z);             % Reshape image to feature vector form
            
            cimg = this.Model.predict(double(img));
            
            cimg = uint8(cimg).*(255/5);
            
            cimg = reshape(cimg, X, Y);             % Reshape to a single-channel image 
        end
        
        %%%%%%%%%%%%%%%%%%%  % Returns classified image unscaled
        % ClassIndexImage %
        %%%%%%%%%%%%%%%%%%%
        function cicm = GetClassIndexImage(this, img)
            
            if (~size(img, 3) == 3)                 % If parameter image does not have 3 channels ..
                if (size(img, 3) == 4)              % Check if it's just an alpha channel ..
                   img = img(:,:,1:3);              % Remove alpha channel 
                else
                    error('PixelClassifier:Classify', 'Parameter image must be a colour image.');
                end
            end
           
            img = rgb2cielab(img);                  % Convert image to LAB colourspace. (Presuming the model used it originally)
            
            [X Y Z] = size(img);                    % Get image dimensions
            
            img = reshape(img, X*Y, Z);             % Reshape image to feature vector form
            
            cicm = this.Model.predict(double(img));
            
            cicm = uint8(reshape(cicm, X, Y));
        end
        
        % 
        function PI = GetProcessedClassIndexImage(this, img);
           
            CI = this.GetClassIndexImage(img);
                        
            Cl = this.GetProcessedLogical(CI, 'LUMEN');
            
            Cs = this.GetProcessedLogical(CI, 'STROMA');
            
            Cc = this.GetProcessedLogical(CI, 'CYTOPLASM');
            
            Cn = this.GetProcessedLogical(CI, 'NUCLEI');
            
            Ci = this.GetProcessedLogical(CI, 'INFLAMMATION');
            
            % Stack masks to produce final processed class index image
            % Order is important here .. 
            PI = zeros(size(CI));
            
            PI(Cs) = 2;
            
            PI(Cc) = 3;
            
            PI(Cl) = 1;
            
            PI(Cn) = 4;
            
            PI(Ci) = 5;
            
            
            while (PI
            
        end
        
        %%%%%%%%%%%%%%%%%%%%%%%% % Classifies image, derives CICM features
        % Obtain CICM Features % 
        %%%%%%%%%%%%%%%%%%%%%%%%
        
        function [FV HIST GLCM] = CICMFeatures(this, img)
            
            cicm = this.GetClassIndexImage(img);
            
            % Simpler than using imhist .. 
            HIST = zeros(1, 5);
            for h = 1:5
                HIST(h) = sum(sum(cicm == (h)));
            end
            
%             offsets = [0 1; 1 1 ; 1 0 ; -1 1
            offsets =  [0 1;-1 1;-1 0;-1 -1]; % 0, 45, 90, 135
            graylimits = [1 5];     % Graylimits and numlevels set so binning doesn't 
            numlevels = 5;          % change assigned pixel classes.
            
            % Don't /think/ symmetric should be used here. 
            % SHOULD CHECK RESULTS FROM BOTH WAYS
            glcm = graycomatrix(cicm, 'Offset', offsets, 'NumLevels', numlevels, 'GrayLimits', graylimits); 
            
            % Sum matrices for total-adjacency matrix
            GLCM = (glcm(:,:,1) + glcm(:,:,2) + glcm(:,:,3) + glcm(:,:,4));

            FV = zeros(1, 25); % Preallocate feature vector
            i = 1;
            for h = 1:5
                for g = 1:5
                  t = HIST(h);
                  b = GLCM(h, g);
                  
                  if (b == 0) % Dividing by zero error
                      b = 1;
                  end
                  
                  FV(i) = t / b;
                  i = i + 1;
                end
            end
            
        end
        
        % Returns a binary image for the specified class from the base
        % classified image values.
        function mask = GetLogical(this, img, class)
            
            idx = 0;
            for i = 1:length(this.Key)
                if strcmp(this.Key(i), class) 
                    idx = i;  break;
                end
            end
            
%             idx_val = idx * (255/5);
            
            mask = false(size(img));    % Create output logical image
            mask(img == idx) = 1;   % Map selected class
        end
        
        
        % Returns a binary image for the specified class from the base
        % classified image values that have been processed on a
        % case-by-case basis.
        function pmask = GetProcessedLogical(this, img, class)
            
             pmask = this.GetLogical(img, class);
             
             if     strcmp(class, 'LUMEN')
                 
                 % do something to lumen
                 
             elseif strcmp(class, 'STROMA')
                 
                 pmask = imopen(pmask, strel('disk', 2));
                 pmask = bwareaopen(pmask, 400);
                 pmask = imfill(pmask, 8, 'holes');
                 
             elseif strcmp(class, 'CYTOPLASM')
                 
                 pmask = bwareaopen(pmask, 800);
                 pmask = imclose(pmask, strel('disk', 2));
                 pmask = imfill(pmask, 8, 'holes');
                 
             elseif strcmp(class, 'NUCLEI')
                 
                 pmask = bwareaopen(pmask, 100);
                 pmask = imopen(pmask, strel('disk', 2));
                 pmask = imdilate(pmask, strel('disk', 2)); % Not sure if necessary
                 pmask = imfill(pmask, 8, 'holes');
                 
             elseif strcmp(class, 'INFLAMMATION') % Inflammation may be removed from model
                 % I think the best way currently is to treat inflammation
                 % as nuclei areas (albeit smaller)
                 
                 pmask = bwareaopen(pmask, 20);
                 
             else
                  error('PixelClassifier::GetProcessedLogical - Invalid class submitted!'); 
             end
        end
       
        % Highlights the border of ROIs in the input image using the input
        % mask.
        function himg = MaskHighlight(this, img, mask)
            
            mask = edge(mask);
            mask = imdilate(mask, strel('disk', 2));
            himg = img;
            r = himg(:,:,1);
            
            r(mask) = 0;
            
            himg(:,:,1) = r;
        end
            
            
        
        
        %%%%%%%%%%%%%%%%%% % Returns cell array of labels for CICM features
        % Feature Labels % 
        %%%%%%%%%%%%%%%%%%
        function FV_labels = CICMFeatureLabels(this)
            
            FV_labels = cell(1,25); % Pre-allocate cell array
            
            i = 1;
            for h = 1:5
                for g = 1:5
                    FV_labels{i} = strcat(this.Key{h}, '-', this.Key{g});
                    i = i + 1;
                end
            end
            
        end 
    end
    
     
    %%%%%%%%%%%%%%%%%%%%%%%%%%  
    % Utility/Misc Functions %
    %%%%%%%%%%%%%%%%%%%%%%%%%%
    
    methods(Static, Access = 'public')
       
        % Reshapes a colour image to feature vector format
        function FV = TileToFeatureVector(tile)
            [X Y Z ] = size(tile);
            FV = reshape(tile, X*Y, Z);
        end
        % Reshapes feature vector back to colour image.
        function T = FeatureVectorToTile(FV, X, Y);
            [~, Z] = size(FV);
            T = reshape(FV, X, Y, Z);
        end
        
      
       
    end
end

